[["index.html", "EVE 109: Molecular Ecology Week 1 Introduction 1.1 Installing R and RStudio 1.2 Tour of RStudio 1.3 Installing packages 1.4 Basic functions in R 1.5 Classes 1.6 Vectors and dataframes 1.7 Subsetting 1.8 Plotting 1.9 Homework", " EVE 109: Molecular Ecology Week 1 Introduction This website provides the material you will need to complete discussion section and homework exercises. Each week, we will go over the commands you need for that week’s assignments. You may work together in class and on homework, but I do expect you to turn in an individual assignment that has been completed on your own and reflects your own understanding of the material. This course is meant to give you an introduction to analyzing genetic data in R, so feel free to take these assignments further where you are interested. Data is fun! 1.1 Installing R and RStudio For most of our analysis in this class, we will work with the programming language “R.” RStudio is a software that provides a nice interface for using R. The very first thing we need to do is install both R and RStudio. The following link has instructions for installing R and RStudio on any laptop: https://datacarpentry.org/R-ecology-lesson/#setup_instructions This website has many tutorials that are relevant to the types of analyses biologists need. Take a moment and install R and RStudio on your laptop. If you are going to be doing homework on a different computer, you will want to install the software on that computer as well. 1.2 Tour of RStudio Next we will take a tour of RStudio as a class. We will cover: The console Scripts Commenting Executing Commands Asking for help 1.3 Installing packages Some special functions or datasets can be downloaded as packages. To install them, we use the install.packages command: install.packages(&quot;babynames&quot;) You only have to install a package once because the package is downloaded to your computer. However, each time you use a package you will need to tell R you are using commands from that package. It’s good practice to place this at the top of your script. library(babynames) 1.4 Basic functions in R R can perform basic mathematical functions, just like a calculator. Type the following into the console and press enter: 10 + 5 # Add ten and five ## [1] 15 To do more complicated analyses, and to make scripts generalizable, we often want to assign values to objects. Type the following in your R script, then execute myvalue &lt;- 10 The arrow &lt;- is how we assign a value to an object. In general, it is better to assign values to objects rather than do math directly on the values. That is because if we want to do several different operations on myvalue but might want to change it later, we only have to change it in one place. Once you have stored a value you can print it, or you can use it to perform further mathematical functions: myvalue #print myvalue ## [1] 10 print(myvalue) #print myvalue ## [1] 10 There’s really no difference between these two ways to print an object myvalue + 5 #add 5 to myvalue ## [1] 15 newvalue &lt;- myvalue + 5 newvalue ## [1] 15 Note: You can choose any name you want for an object, but be careful! The name should be short (you may have to type it many times), but informative (so you don’t get it confused with other objects). You cannot use spaces and you cannot begin an object name with a number. You can use capitalization and underscore to your advantage, for example: thisIsAnObject or this_is_an_object 1.4.1 Exercise: Write a script to find out what fraction of your life you’ve been at UC Davis Include objects for your age and the number of years you’ve been at Davis. Have the script print the answer. 1.5 Classes R can work with more than just numbers, it can handle a variety of data formats. You can use the function class to check the type of data: class(myvalue) ## [1] &quot;numeric&quot; But what happens if we assign an object to something other than a number? season &lt;- &quot;fall&quot; class(season) ## [1] &quot;character&quot; Two somewhat confusing classes are character and factor. character means a string of letters while factor represents categorical data. For plotting and summarizing, we often want factor data. We can convert character data to factor data using the as.factor command: season_factor &lt;- as.factor(season) class(season_factor) ## [1] &quot;factor&quot; 1.6 Vectors and dataframes Usually we want to look at more than one number or value at once. For a single set of values, we can use a vector. To make a vector, we use the c() function (c stands for combine) seasons &lt;- c(&quot;fall&quot;,&quot;winter&quot;,&quot;spring&quot;,&quot;summer&quot;) Perhaps the most common way to format data is in a dataframe. This is basically a spreadsheet, like you would make in Excel. R has a few example dataframes that we can use. We installed one earlier when we installed the babynames package. Look at the top of this dataframe (the head command gives just the first 5 entries): head(babynames) ## # A tibble: 6 x 5 ## year sex name n prop ## &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; &lt;int&gt; &lt;dbl&gt; ## 1 1880 F Mary 7065 0.0724 ## 2 1880 F Anna 2604 0.0267 ## 3 1880 F Emma 2003 0.0205 ## 4 1880 F Elizabeth 1939 0.0199 ## 5 1880 F Minnie 1746 0.0179 ## 6 1880 F Margaret 1578 0.0162 dim(babynames) # how many rows and columns are in the dataframe? ## [1] 1924665 5 dim gives you the dimensions of the dataframe. Remember, we can always use ? to ask for help. If we want a description of the babynames dataframe: ?babynames 1.7 Subsetting Sometimes we want to examine a specific portion of the data. There are several ways to do this. For a two-dimensional dataframe you can use square bracket notation [x,y] where x is the rows you want and y is the columns you want. Like this: babynames[1:4,c(2,3)] #take the first four rows and columns 2 &amp; 3 ## # A tibble: 4 x 2 ## sex name ## &lt;chr&gt; &lt;chr&gt; ## 1 F Mary ## 2 F Anna ## 3 F Emma ## 4 F Elizabeth Notice the : gives me all the integers between 1 and 4. You can also ask for columns by name using the $ notation. This means you can use the column name to ask for a single column out of the dataframe. Note that this does not work for rows. head(babynames$name) ## [1] &quot;Mary&quot; &quot;Anna&quot; &quot;Emma&quot; &quot;Elizabeth&quot; &quot;Minnie&quot; &quot;Margaret&quot; You can use the subset function to ask for rows that meet certain criteria. Notice the double ==. You use this when you are comparing values. myname &lt;- &quot;Rachael&quot; mydata &lt;- subset(babynames,name==myname) # take just the entries where name = &quot;Rachael&quot; head(mydata) ## # A tibble: 6 x 5 ## year sex name n prop ## &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; &lt;int&gt; &lt;dbl&gt; ## 1 1880 F Rachael 12 0.000123 ## 2 1881 F Rachael 8 0.0000809 ## 3 1882 F Rachael 8 0.0000692 ## 4 1883 F Rachael 9 0.0000750 ## 5 1884 F Rachael 7 0.0000509 ## 6 1885 F Rachael 8 0.0000564 dim(mydata) ## [1] 158 5 1.8 Plotting R is great for plotting. The simplest type of plot is just an x,y scatterplot: plot(mydata$year,mydata$prop) Use ? to look at the options for plotting. For example, here I add more informative axis labels and choose a nice color for the points: plot(mydata$year,mydata$prop, ylab=&quot;Proportion of babies&quot;, xlab=&quot;Year&quot;, col=&quot;aquamarine4&quot;) Notice that I used new lines (returns) to make this more readable. R doesn’t care where you put white space, so use it to make your code as organized as possible. Of course, it’s better if color is informative, so lets use it to learn something. Isn’t it weird that there are a bunch of points at 0 and other points with higher proportions during the same time frame? Maybe those points are different in some way. Lets try this: plot(mydata$year,mydata$prop, ylab=&quot;Proportion of babies&quot;, xlab=&quot;Year&quot;, col=as.factor(mydata$sex)) 1.8.1 Exercise: Describe this plot in plain english. What conclusions can we draw? 1.9 Homework Each week, you will submit a script for homework. While most of the concepts you will need will be taught during section, you may have to look up some commands online (remember, Google is your friend!). The top of your script should contain commented lines with the following: #Name #Date #EVE 109 Homework #Week ## I should be able to execute the script. When printed answers are expected, you should store them in an object and have a line of code above should have a comment telling me where the answer is printed. For example: #Answer to Question 1 print(myvalue) ## [1] 10 If the answer requires a plot, follow the same format, with a comment indicating that this plot answers a homework question: #Answer to Question 2 plot(mydata$year,mydata$prop) Show your work and comment your code. You will only receive full credit for clean, organized code 1.9.1 Homework 1: Write a script that does the following: Plot the use of your name over time (Or pick a different name). Only include points for one sex. What proportion of babies had your name when it was most popular? In which year was your name most popular? "],["molecular-markers.html", "Week 2 Molecular Markers 2.1 Paths 2.2 Reading in data from spreadsheets 2.3 Simple capture recapture example 2.4 Homework", " Week 2 Molecular Markers 2.1 Paths For this course, I will upload the datasets you need to this website and you will download them to your own computer. You will then need to figure out how tell R where to find them. You can find out what directory you are currently in using the getwd() command: getwd() ## [1] &quot;/Users/rachaelbay/Documents/Courses/Molecular Ecology/2021/Website&quot; Directories are hierarchical: the represent folders within folders just like you view them when you navigate with your mouse. You can also set which directory R will use to look for files. This is called your ‘working directory’ and you can set it using setwd(). For example, if I create a folder called \"EVE109 inside my documents folder where I want to store all my materials for this class, I can then tell R I want it to look in that directory for files: setwd(&quot;~/Documents/EVE109&quot;) If you get an error that your file cannot be found, a good first step is to check your working directory. 2.2 Reading in data from spreadsheets Today we will be working with data from the paper we read in class. You can download the dataset here A lot of data we use is stored in spreadsheets. However, when we store them in a normal Excel format (.xlsx) they come with a lot of extra formatting that R has trouble reading. One way to avoid this is to store them in a comma separated value format (.csv). Open “wombats.csv” in a text editor and look at it. It’s not easy for us to read, but you can see that it is a very simple format where each entry is separated by a comma. You were able to open it in a spreadsheet program and R can read it easily. If you are making your own data, you can save spreadsheets as .csv files from most spreadsheet programs. Now we want to read that data into RStudio. We can do that using the command read.csv. Remember do assign the resulting data frame to an object: data &lt;- read.csv(&quot;data/wombats.csv&quot;) # Read in a file Remember, we can look at the top of the dataframe using head: head(data) ## No.captures total males females ## 1 1 25 18 7 ## 2 2 11 7 4 ## 3 3 10 7 3 ## 4 4 10 6 4 ## 5 5 9 6 3 ## 6 6 11 6 5 This is data from the paper we read this week by Banks et al. (2003) using genetic analysis to monitor northern hairy-nosed wombats. The table represents the data shown in Figure 1, so individuals have already been identified and we’re looking at the number of times each was recaptured. 2.3 Simple capture recapture example Next we will learn a simple way to make population size estimations. We will use the capwire package to do this. Remember how to install and load a package? install.packages(&quot;capwire&quot;) library(capwire) The manual for capwire can be found online here Okay, now lets make up some data. Luckily, capwire has a function that allows you to simulate data. Look up the function simCapture. Notice there are three different arguments we need to specify (we can ignore return.cap.probs because it has a default that we do not want to change). Using this function we’ll simulate a population of 300, from which we have 50 samples. This distribution function just means that every individual has an equal probability of being captured. sim &lt;- simCapture(n=300,s=50,dist.func=drawCapRatesUnif(0.1,1)) # Simulate capture data sim ## capture.class No.Ind ## 1 1 41 ## 2 2 3 ## 3 3 1 Now that we have simulated data, we can use one of the fitEcm function to estimate population size. What arguments do we need for that function? Notice that the help page tells you what format your data should be in. ecm &lt;- fitEcm(data=sim,max.pop=500) # estimate population size The fitEcm page also describes that output. We are most interested in the population size estimate, which is called ml.pop.size. We can extract that using: ecm$ml.pop.size ## [1] 228 How much uncertainty is there in our estimate? We can use bootstrap resampling to create confidence intervals. Look up the command boostrapCapwire boot &lt;- bootstrapCapwire(x=ecm,bootstraps=1000,CI=c(0.025,0.975)) # estimate confidence intervals boot ## $ml.pop.size ## [1] 228 ## ## $conf.int ## 2.5% 97.5% ## 119 500 Using this 95% confidence interval means there is a 95% chance the real answer is within that range. Why is it so large?! What happens if we have more samples? 2.4 Homework Now that we know how to estimate population sizes, we will use the wombat data from before. Start a new script for this. 2.4.1 Homework 2: Write a script that does the following: Read in “wombats.csv” Estimate the total population size. Estimate confidence intervals for the total population size. Estimate male and female population sizes. What is the ratio of males to females in this population? "],["genetic-diversity.html", "Week 3 Genetic Diversity 3.1 Manipulating dataframes 3.2 Using the adegenet package to calulate heterozygosity 3.3 Homework", " Week 3 Genetic Diversity 3.1 Manipulating dataframes As we saw last week, the most common class we work with in R is a dataframe. This week, we’ll learn a few more ways to manipulate dataframes. This time we’ll use the built in palmerpenguins dataset: install.packages(&quot;palmerpenguins&quot;) library(palmerpenguins) head(penguins) ## # A tibble: 6 x 9 ## species island bill_length_mm bill_depth_mm flipper_length_… body_mass_g sex year mean ## &lt;fct&gt; &lt;fct&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;int&gt; &lt;int&gt; &lt;fct&gt; &lt;int&gt; &lt;dbl&gt; ## 1 Adelie Torger… 39.1 18.7 181 3750 male 2007 997. ## 2 Adelie Torger… 39.5 17.4 186 3800 fema… 2007 1011. ## 3 Adelie Torger… 40.3 18 195 3250 fema… 2007 876. ## 4 Adelie Torger… NA NA NA NA &lt;NA&gt; 2007 NA ## 5 Adelie Torger… 36.7 19.3 193 3450 fema… 2007 925. ## 6 Adelie Torger… 39.3 20.6 190 3650 male 2007 975. One quick way to explore the data is using summary: summary(penguins) ## species island bill_length_mm bill_depth_mm flipper_length_mm ## Adelie :152 Biscoe :168 Min. :32.10 Min. :13.10 Min. :172.0 ## Chinstrap: 68 Dream :124 1st Qu.:39.23 1st Qu.:15.60 1st Qu.:190.0 ## Gentoo :124 Torgersen: 52 Median :44.45 Median :17.30 Median :197.0 ## Mean :43.92 Mean :17.15 Mean :200.9 ## 3rd Qu.:48.50 3rd Qu.:18.70 3rd Qu.:213.0 ## Max. :59.60 Max. :21.50 Max. :231.0 ## NA&#39;s :2 NA&#39;s :2 NA&#39;s :2 ## body_mass_g sex year mean ## Min. :2700 female:165 Min. :2007 Min. : 738.9 ## 1st Qu.:3550 male :168 1st Qu.:2007 1st Qu.: 950.9 ## Median :4050 NA&#39;s : 11 Median :2008 Median :1076.6 ## Mean :4202 Mean :2008 Mean :1115.9 ## 3rd Qu.:4750 3rd Qu.:2009 3rd Qu.:1257.5 ## Max. :6300 Max. :2009 Max. :1646.3 ## NA&#39;s :2 NA&#39;s :2 For quantitative columns, this gives you basic summary statistics and for categorical columns it gives you counts of each value. We could have also looked at the categorical data using the table command: table(penguins$Species) ## Warning: Unknown or uninitialised column: `Species`. ## &lt; table of extent 0 &gt; Let’s take just the quantitative data for a moment: quant &lt;- penguins[,3:6] head(quant) ## # A tibble: 6 x 4 ## bill_length_mm bill_depth_mm flipper_length_mm body_mass_g ## &lt;dbl&gt; &lt;dbl&gt; &lt;int&gt; &lt;int&gt; ## 1 39.1 18.7 181 3750 ## 2 39.5 17.4 186 3800 ## 3 40.3 18 195 3250 ## 4 NA NA NA NA ## 5 36.7 19.3 193 3450 ## 6 39.3 20.6 190 3650 For easy summaries of rows or columns, we can us the commands colSums, colMeans, rowSums, and rowMeans means &lt;- rowMeans(quant) Maybe we want to add a column to the initial iris dataframe that has the mean of the different measurements. We can do that in two different ways: penguins$mean &lt;- rowMeans(quant) # Caluclate and name the new column at the same time or... means2 &lt;- rowMeans(quant) # Calculate means newpenguins &lt;- cbind(penguins,means2) # cbind (column bind) to iris dataframe head(newpenguins) ## species island bill_length_mm bill_depth_mm flipper_length_mm body_mass_g sex year ## 1 Adelie Torgersen 39.1 18.7 181 3750 male 2007 ## 2 Adelie Torgersen 39.5 17.4 186 3800 female 2007 ## 3 Adelie Torgersen 40.3 18.0 195 3250 female 2007 ## 4 Adelie Torgersen NA NA NA NA &lt;NA&gt; 2007 ## 5 Adelie Torgersen 36.7 19.3 193 3450 female 2007 ## 6 Adelie Torgersen 39.3 20.6 190 3650 male 2007 ## mean means2 ## 1 997.200 997.200 ## 2 1010.725 1010.725 ## 3 875.825 875.825 ## 4 NA NA ## 5 924.750 924.750 ## 6 974.975 974.975 3.2 Using the adegenet package to calulate heterozygosity Today we’ll use microsatellite data from the Weeks et al. (2017) paper using genetic analysis to look at the effects of population recovery after an introduction. You can download it here. Let’s read in this file: data &lt;- read.csv(&quot;data/weeks_genotypes.csv&quot;) # Read in a file Take a look at the data: head(data) ## ID Pop Year LOC1 LOC2 LOC3 LOC4 LOC5 LOC6 LOC7 LOC8 LOC9 ## 1 1 MtBuller 2010 311/311 245/249 303/303 195/201 218/218 211/211 321/321 240/240 157/157 ## 2 2 MtBuller 2010 311/311 245/249 303/303 195/201 218/218 211/211 321/321 240/240 157/157 ## 3 3 MtBuller 2010 311/311 245/249 303/303 NA/NA 218/218 211/211 321/321 240/240 157/157 ## 4 4 MtBuller 2010 311/311 249/249 303/303 195/195 218/218 211/211 321/321 240/240 157/157 ## 5 5 MtBuller 2010 309/311 249/249 303/303 195/201 218/218 211/211 321/321 240/240 157/157 ## 6 6 MtBuller 2010 309/311 NA/NA 303/303 201/201 218/218 211/211 321/321 240/240 157/157 ## LOC10 LOC11 LOC12 LOC13 LOC14 LOC15 LOC16 LOC17 LOC18 LOC19 LOC20 ## 1 113/113 178/178 125/125 309/318 119/119 144/146 214/214 241/241 160/160 150/150 117/117 ## 2 113/113 178/178 125/125 309/309 119/148 144/146 214/214 241/241 160/160 150/150 117/117 ## 3 113/113 178/178 125/125 309/309 119/119 144/144 214/216 241/241 160/160 150/150 117/117 ## 4 113/113 178/178 125/125 309/309 119/119 144/146 214/214 241/241 160/160 150/150 117/117 ## 5 113/115 178/178 125/125 309/318 148/148 144/146 216/216 241/241 160/160 150/150 117/117 ## 6 113/115 178/178 125/125 309/318 119/148 144/144 214/214 241/241 160/160 150/150 117/117 ## LOC21 LOC22 LOC23 LOC24 ## 1 141/141 137/137 157/157 177/177 ## 2 141/141 137/137 157/157 177/177 ## 3 141/141 137/137 157/157 177/177 ## 4 141/141 137/137 157/157 177/177 ## 5 141/141 137/141 157/157 177/177 ## 6 141/141 137/137 157/157 177/177 The first column is an id assigned to each individual. The second column gives the populations from which the individual was sampled. The third column gives the year of sampling. The remaining columns give the microsatellite data. Each individual has two numbers which represent the fragment lengths (read on a gel). If the two fragment lengths are the same, the individual is a heterozygote. If they are different, the individual is a homozygote. We will use the package adegenet to read in the microsatellite data and calculate heterozygosity. The manual for this package is here. Install the package and call the library: install.packages(&quot;adegenet&quot;) library(adegenet) The first thing we need to do is let the adegenet read in the microsatellite data. We can do this with the df2genind. Let’s ask for help on that command: ?df2genind Look at the arguments. How can we format our allele data to meet the requirements of the package? alleles &lt;- data[,4:ncol(data)] The function ncol gives us the number of columns. So here we are asking for all columns except the first three, which do not contain genotype data. Okay, let’s see if that works genind &lt;- df2genind(alleles,sep=&quot;/&quot;,NA.char=&quot;NA/NA&quot;) summary(genind) ## ## // Number of individuals: 524 ## // Group sizes: 524 ## // Number of alleles per locus: 5 5 10 7 8 3 7 16 3 11 10 2 6 10 5 2 10 2 5 3 2 10 9 4 ## // Number of alleles per group: 155 ## // Percentage of missing data: 1.03 % ## // Observed heterozygosity: 0.12 0.68 0.29 0.6 0.48 0.3 0.36 0.38 0.35 0.64 0.43 0.22 0.54 0.6 0.5 0.21 0.38 0.25 0.25 0.17 0.17 0.39 0.26 0.25 ## // Expected heterozygosity: 0.12 0.64 0.36 0.7 0.58 0.32 0.5 0.56 0.51 0.74 0.56 0.45 0.64 0.61 0.63 0.25 0.44 0.46 0.29 0.19 0.35 0.49 0.33 0.38 The object summary has most of the information we want: results &lt;- summary(genind) names(results) # Show the different output values we can look at ## [1] &quot;n&quot; &quot;n.by.pop&quot; &quot;loc.n.all&quot; &quot;pop.n.all&quot; &quot;NA.perc&quot; &quot;Hobs&quot; &quot;Hexp&quot; results$Hobs # Show observed heterozygosity ## LOC1 LOC2 LOC3 LOC4 LOC5 LOC6 LOC7 LOC8 LOC9 ## 0.1150097 0.6812749 0.2913386 0.5984405 0.4799235 0.2972973 0.3556405 0.3754864 0.3512476 ## LOC10 LOC11 LOC12 LOC13 LOC14 LOC15 LOC16 LOC17 LOC18 ## 0.6382979 0.4335260 0.2160612 0.5393474 0.5965583 0.4990366 0.2103250 0.3754789 0.2471264 ## LOC19 LOC20 LOC21 LOC22 LOC23 LOC24 ## 0.2480620 0.1739962 0.1685824 0.3850575 0.2553191 0.2528736 Notice that observed and expected heterozygosity have been calculated, but across the entire dataset. What if we supply different populations? We use the seppop function to tell it we want separate measurements for each population genindPop &lt;- df2genind(alleles,sep=&quot;/&quot;, NA.char=&quot;NA/NA&quot;, pop=data$Pop) genindPop &lt;- seppop(genindPop) genindPop ## $MtBuller ## /// GENIND OBJECT ///////// ## ## // 420 individuals; 24 loci; 155 alleles; size: 316.4 Kb ## ## // Basic content ## @tab: 420 x 155 matrix of allele counts ## @loc.n.all: number of alleles per locus (range: 2-16) ## @loc.fac: locus factor for the 155 columns of @tab ## @all.names: list of allele names for each locus ## @ploidy: ploidy of each individual (range: 2-2) ## @type: codom ## @call: .local(x = x, i = i, j = j, pop = ..1, treatOther = ..2, quiet = ..3, ## drop = drop) ## ## // Optional content ## @pop: population of each individual (group size range: 420-420) ## ## $MtHigginbotham ## /// GENIND OBJECT ///////// ## ## // 104 individuals; 24 loci; 155 alleles; size: 102.9 Kb ## ## // Basic content ## @tab: 104 x 155 matrix of allele counts ## @loc.n.all: number of alleles per locus (range: 2-16) ## @loc.fac: locus factor for the 155 columns of @tab ## @all.names: list of allele names for each locus ## @ploidy: ploidy of each individual (range: 2-2) ## @type: codom ## @call: .local(x = x, i = i, j = j, pop = ..1, treatOther = ..2, quiet = ..3, ## drop = drop) ## ## // Optional content ## @pop: population of each individual (group size range: 104-104) Notice the two locations are now separate. We can get the heterozygosity separately for each population: MtBuller &lt;- summary(genindPop$MtBuller) MtHiggenbotham &lt;- summary(genindPop$MtHigginbotham) MtBuller$Hobs # Observed heterozygosity for all Mt Buller Samples ## LOC1 LOC2 LOC3 LOC4 LOC5 LOC6 LOC7 LOC8 LOC9 ## 0.1196172 0.6526055 0.2120482 0.5649038 0.3937947 0.2583732 0.2911695 0.3325359 0.3381295 ## LOC10 LOC11 LOC12 LOC13 LOC14 LOC15 LOC16 LOC17 LOC18 ## 0.6201923 0.3317422 0.2696897 0.5083532 0.5751790 0.4892086 0.2625298 0.2559809 0.3086124 ## LOC19 LOC20 LOC21 LOC22 LOC23 LOC24 ## 0.1654676 0.1527446 0.1360382 0.3110048 0.1558753 0.1531100 MtBuller$Hexp # Expected heterozygosity for all Mt Buller Samples ## LOC1 LOC2 LOC3 LOC4 LOC5 LOC6 LOC7 LOC8 LOC9 ## 0.1129982 0.6064596 0.2329279 0.6085111 0.4022334 0.2458735 0.2869544 0.3583595 0.3399151 ## LOC10 LOC11 LOC12 LOC13 LOC14 LOC15 LOC16 LOC17 LOC18 ## 0.6384350 0.3431457 0.3045010 0.5145363 0.5734332 0.5079217 0.3030058 0.2639076 0.3282291 ## LOC19 LOC20 LOC21 LOC22 LOC23 LOC24 ## 0.1647056 0.1750275 0.1629775 0.3484438 0.1637021 0.1735194 3.2.1 Plotting heterozygosity Let’s use a barplot to look at variation in heterozygostiy across all our markers: barplot(MtBuller$Hobs) When we have a bunch of markers, we often take the mean across all those markers: mean(MtHiggenbotham$Hobs) # Mean observed heterozygosity in the Mt Higgenbotham population ## [1] 0.5262125 Compare this value to the paper. 3.3 Homework Now that we know how to estimate observed and expected heterozygosity, we’ll look at changes over time. Start a new script for your homework ###Homework 3: Write a script that does the following: 1. Read in “genotypes.csv” and subset the dataframe to Mt Buller samples only. How many samples do you have from each year? 2. Calculate mean observed heterozygosity for each year. Put these into a single dataframe. 3. Calculate mean expected heterozygosity for each year. Add these to the dataframe from question 2. 4. Plot mean expected heterozygosity over time. 5. Add a vertical lines to your plot to show when introductions took place (hint - use the abline command) "]]
